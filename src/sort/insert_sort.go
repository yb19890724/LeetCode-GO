package sort

// 插入排序 类似扑克牌 排序

// 完全有序的情况下最好，O(n)级别

// 执行流程
// 1.在执行过程中，插入排序会将序列分为2部分
// 头部已经排好序的，尾部 是待排序的

// 2.从头开始扫描每一个元素
// 每当扫描到一个元素 ，就将它插入到头部适合的位置，使得头部数据依然保持有序

// 第一轮： [4] 2 9 1 拿待排序的第二个数 2，插入到排好序的数列 [4]
//    与排好序的数列 [4] 比较
//    第一轮进行中：2 比 4 小，插入到 4 前
// 第二轮： [2 4] 9 1 拿待排序的第三个数 9，插入到排好序的数列 [2 4]
//    与排好序的数列 [2 4] 比较
//    第二轮进行中： 9 比 4 大，不变化
// 第三轮： [2 4 9] 1 拿待排序的第四个数 1，插入到排好序的数列 [2 4 9]
//    与排好序的数列 [2 4 9] 比较
//    第三轮进行中： 1 比 9 小，插入到 9 前
//    第三轮进行中： 1 比 4 小，插入到 4 前
//    第三轮进行中： 1 比 2 小，插入到 2 前
// 结果： [1 2 4 9]


func InsertSort(data []int) []int {
	
	for i := 1; i <=len(data) -1; i++ {
		deal := data[i] // 待排序的数
		j := i - 1      // 待排序的数左边的第一个数的位置
		
		// 如果第一次比较，比左边的已排好序的第一个数小，那么进入处理
		for ; j >= 0 && deal < data[j]; j-- {
			data[j+1] = data[j] // 某数后移，给待排序留空位
		}
		data[j+1] = deal // 结束了，待排序的数插入空位
	}
	return data
	
	
	
	
	//
	// for i := range data {
	//
	// 	preIndex := i - 1
	// 	current := data[i]
	//
	// 	// 前一个数据与后面数据进行比较，如果前面大于后面的进行交换
	// 	for preIndex >= 0 && data[preIndex] > current {
	// 		data[preIndex+1] = data[preIndex]
	// 		preIndex -= 1
	// 	}
	// 	data[preIndex+1] = current
	// }
	// return data
	
}